#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <unistd.h>
/* #include <wordexp.h> */
#include <fcntl.h>
#include <signal.h>
#include <sys/types.h>
#include <sys/wait.h>

// Defining a lot of things.
#define  MAX_LINE      1024
#define  MAX_BG        30
#define  MAX_TOKS      100
#define  MAX_COMMANDS  10

// Terminal Colors from: http://stackoverflow.com/questions/3585846/color-text-in-terminal-aplications-in-unix
#define  KNRM   "\x1B[0m"
#define  KRED   "\x1B[31m"
#define  KGRN   "\x1B[32m"
#define  KYEL   "\x1B[33m"
#define  KBLU   "\x1B[34m"
#define  KMAG   "\x1B[35m"
#define  KCYN   "\x1B[36m"
#define  KWHT   "\x1B[37m"
#define  RESET  "\033[0m"

// Initialize debugging to a global, initially off.
int debug = 0;

// REPL loop w/ ampersand is false initially.
int ampersand = 1;

// Color & prompt.
void printColor(char * color, char * string) {
    printf("%s%s%s", color, string, RESET);
}

void printColors() {
    printColor(KRED, "red\n");
    printColor(KGRN, "green\n");
    printColor(KYEL, "yellow\n");
    printColor(KBLU, "blue\n");
    printColor(KMAG, "magenta\n");
    printColor(KCYN, "cyan\n");
    printColor(KWHT, "white\n");
    printColor(KNRM, "normal\n");
}

pid_t child = 1;
void printPrompt() {
    char cwd[MAX_LINE];
    // Get the current working directory.
    getcwd(cwd, sizeof(cwd));
    // Print it out above the prompt line in cyan.
    printf(KCYN "\n%s\n", cwd);
    // Print the prompt in a nice magenta.
    char * child_status = child_status = (child) ? "parent " : "child ";
    if (debug) printColor(KYEL, child_status);
    printColor(KMAG, "$: ");
}

void printRainbow() {
    for (int spaces = 5; spaces > 0; spaces--) {
        int leads = spaces * spaces/(1.5);
        int between = (5 - spaces) * (8.5);
        between = (5 - spaces) * 10;
        char * star = "***";
        printf("%d: %*s%*s\n", between, leads, star, between, star);
    }
}

int isEmpty(const char * s) {
    while (* s != '\0') {
        if (!isspace(* s)) {
            return 0;
        }
        s++;
    }
    return 1;
}

void printArray(char * array[]) {
    int i = -1;
    while (array[++i] != NULL) {
        printf("arg[%d]: =  \"%s\"\n", i, array[i]);
    }
    printf("arg[%d]: =  \"%s\"\n", i, array[i]);
    printf("\n");
}

int arraySize(char * array[]) {
    // Return the number of non-NULL, contiguous members of an array.
    int size = 0;
    while (array[size++] != NULL) {
        // Counting the array size.
    }
    return size;
}

void shift(char * args[], int i) {
    int j = 0;
    while (args[i + j++] != NULL) {
        args[i + j - 1] = args[i + j];
    }
}

void parseCommands(char input[], char * args[]) {
    // Based on http://www.tutorialspoint.com/c_standard_library/c_function_strtok.htm
    const char delimiter[2] = " ";
    const char carrats[3] = "><";
    char * hasCarrats;
    /* const char connectors[4] = "><&|"; */
    int i = 0;
    args[i] = strtok(input, delimiter);

    // Read in each argument, up to the maximum number of tokens.
    while ( args[i] != NULL && i < MAX_TOKS) {
        args[++i] = strtok(NULL, delimiter);
        /* if (args[i] != NULL) { */
        /*     hasConnectors = strpbrk(args[i], connectors); */
        /*     // If there's a connector character in the argument list ... */
        /*     if (hasConnectors != NULL) { */
        /*         if (debug) printf("First matching character: %c\n", * hasConnectors); */
        /*         if (debug) printf("args[%d] is %s\n", i, args[i]); */
        /*         args[i] = strtok(args[i], hasConnectors); */
        /*         // The line below is causing the segfault :( */
        /*         // But, this sort of double seperation is only for extra credit */
        /*         // so maybe just abandon it for now??? */
        /*         #<{(| args[++i] = strtok(NULL,  hasConnectors); |)}># */
        /*     } */
        /* } */
    }

    // Strip the last argument of the newline character or set it to null if it's extra whitespace.
    char * lastArg = args[--i];
    args[i] = isEmpty(lastArg) ? NULL : strtok(lastArg, "\n");
    if ((strcmp(lastArg, "&") == 0) | (lastArg == NULL && (strcmp(args[i - 1], "&")))) {
        ampersand = 0;
        if (strcmp(lastArg, "&") == 0) {
            args[i] = NULL;
        } else if (strcmp(args[i - 1], "&")) {
            args[i - 1] = NULL;
        }
    }

    int fd;
    if (arraySize(args) > 2) {
        i = 1;
        hasCarrats = strpbrk(args[i], carrats);
        while (args[i] != NULL) {
            if (hasCarrats) {
                switch (hasCarrats[0]) {
                    case '<':
                        printf("got a <\n");
                        fd = open(args[i - 1], O_RDONLY);
                        shift(args, i);
                        dup2(fd, STDIN_FILENO);
                        break;
                    case '>':
                        printf("got a >\n");
                        fd = open(args[i - 1], O_RDONLY | O_CREAT);
                        dup2(fd, STDOUT_FILENO);
                        shift(args, i);
                        break;
                }
            }
            if (debug) printf("carrat @ index %d: %s\n", i, hasCarrats);
            hasCarrats = strpbrk(args[i++], carrats);
        }
    }
}

void myinfo() {
    printf("PID: %lu\nPPID: %lu\n", (long) getpid(), (long) getppid);
}

int checkForBuiltin(char * args[]) {
    char * builtins[5] = { "exit", "myinfo", "cd", "rainbow", NULL };
    int hasAbuiltin = 0; // False
    int i = -1, j = -1;
    while (args[++i] != NULL) {
        while (builtins[++j] != NULL) {
            /* if (debug) printf("args[%d]: %s & builtins[%d]: %s\n", i, args[i], j, builtins[j]); */
            hasAbuiltin = (strcmp(args[i], builtins[j]) == 0);
            if (hasAbuiltin) return hasAbuiltin;
        }
        j = -1;
    }

    return hasAbuiltin;
}

void printFail (char * command) {
    printf("shell: command not found: %s\n", command);
}


int execBuiltin(char * args[]) {
    if (strcmp(args[0], "myinfo") == 0) {
        myinfo();
    } else if (strcmp(args[0], "cd") == 0) {
        if (arraySize(args) > 2) {
            // Word expansion found at: http://man7.org/linux/man-pages/man3/wordexp.3.html
            /* wordexp_t p; */
            /* wordexp(args[1], &p, 0); */
            /* char * expanded = *p.we_wordv; */
            /* args[1] = expanded; */
            /* if (debug) printf("expanded to: %s", expanded); */
            int ret = chdir(args[1]);
            if (ret) {
                fprintf(stderr, "cd: problem with %s : ", args[1]);
                perror("");
            }
            /* wordfree(&p); */
        } else {
            int ret = chdir(getenv("HOME"));
            if (ret) {
                printf("HOME not set.");
            }
        }
    } else if (strcmp(args[0], "exit") == 0) {
        printf("bye!\n");
        exit(0);
    } else if (strcmp(args[0], "rainbow") == 0) {
        printColors();
        printRainbow();
    } else {
        printFail(args[0]);
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}

void handle_sigchld(int sig) {
    (void) sig;
    while (waitpid((pid_t)(-1), 0, WNOHANG) > 0) {
        // Reap.
    }
}

void intHandler(int sig) {
    signal(sig, intHandler);
    kill(child, SIGTERM);
    signal(sig, SIG_IGN);
}

int main(int argc, char * argv[]) {
    // Silence unused argc warning.
    (void) argc;
    signal(SIGINT, SIG_IGN);
    if (argv[1] != NULL) {
        debug = argv[1][1] == 'd' ? 1 : 0;
    }
    if (debug) printf("Debugging is on!\n");

    char input[MAX_LINE];
    char * args[MAX_TOKS + 1] = { NULL };
    printPrompt();

    while (fgets(input, MAX_LINE, stdin) != NULL) {
        parseCommands(input, args);
        // If we don't have any arguments, just skip processing!
        if (args[0] == NULL) {
            printPrompt();
            continue;
        }
        if (checkForBuiltin(args)) {
            execBuiltin(args);
        } else {
            child = fork();
            /* signal(SIGCHLD, handle_sigchld); */

            if (child) {
                // I am the parent
                signal(SIGINT, SIG_IGN);
                if (debug) printf(KRED "child: %lu\n" RESET, (long) child);
                int status = 0;
                pid_t mykid = wait(&status);
                /* pid_t mykid = waitpid( child, &status, WNOHANG); */
                if (debug) printf(KMAG "This is me %lu, this iswho terminated! %d\n" RESET, (long) getpid(), mykid);
                if (debug) {
                    printf("Parent is running again\n");
                    printf("Argument list: \n");
                    printArray(args);
                }
                if (WIFEXITED(status)) {
                    if (debug) printf("Child exited normally, return value was %d\n", WEXITSTATUS(status));
                } else {
                    if (debug) printColor(KRED, "Child exited abnormally. :-(\n");
                }
            } else {
                // I am the child
                signal(SIGINT, intHandler);
                if (debug) printf(KRED "child: %lu\n" RESET, (long) child);
                if (debug) printf("execvp-ing: %s\n", args[0]);
                // dup2 stdio
                // alter args to just run the program.
                execvp(args[0], args);
                printFail(args[0]);
                return EXIT_FAILUREd;
            }
        }
        signal(SIGCHLD, SIG_IGN);
        signal(SIGCHLD, handle_sigchld);
        printPrompt();
    }
    return EXIT_SUCCESS;
}
